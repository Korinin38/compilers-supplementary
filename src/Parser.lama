-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop (l, op , r) { Binop (op, l, r) }

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
                          exp = memo $ eta (expr (
                          {
                            [Left , {[s ("!!"), binop ]}],
                            [Left , {[s ("&&"), binop ]}],
                            [Nona , {[s ("=="), binop ], [s ("!="), binop ], [s (">"), binop ], [s ("<"), binop ], [s (">="), binop ], [s ("<="), binop ]}],
                            [Left , {[s ("+"), binop ], [s ("-"), binop ]}],
                            [Left , {[s ("*"), binop ], [s ("/"), binop ], [s ("%"), binop ]}]
                          }, primary));

var endIf = memo $ eta syntax (
  kFi {Skip}
| kElse body=stmt kFi {body}
| kElif condition=exp kThen doThen=stmt doElse=endIf {If (condition, doThen, doElse)}
  );

var simpleStmt = memo $ eta syntax (
  kSkip { Skip }
| x=lident s[":="] e=exp { Assn (x, e) }
| kRead x=inbr[s("("), lident, s(")")] { Read (x) }
| kWrite e=inbr[s("("), exp, s(")")] { Write (e) }
| kIf condition=exp kThen doThen=stmt doElse=endIf { If (condition, doThen, doElse) }
| kWhile condition=exp kDo body=stmt kOd {While (condition, body)}
| kDo body=stmt kWhile condition=exp kOd {DoWhile (condition, body)}
| kFor init=stmt s[","] condition=exp s[","] iter=stmt kDo body=stmt kOd { Seq(init, While (condition, Seq(body, iter)))}
  );

var stmt = memo $ expr ({[Left, {[s (";"), fun (l, op, r) { Seq (l, r) }]}]}, simpleStmt);

-- Public top-level parser
public parse = stmt;
